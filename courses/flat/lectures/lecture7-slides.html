<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="dcterms.date" content="2019-11-17">
  <title>FLAT</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../../../presentation/reveal.js/css/reset.css">
  <link rel="stylesheet" href="../../../presentation/reveal.js/css/reveal.css">
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../../../presentation/reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '../../../presentation/reveal.js/css/print/pdf.css' : '../../../presentation/reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="../../../presentation/reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <script src="../../../presentation/katex/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="../../../presentation/katex/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">FLAT</h1>
  <p class="subtitle">7. Context-Free Languages</p>
  <p class="date">November 17, 2019</p>
</section>

<section class="slide level1">

<style>
.ninety {
   font-size: 90%;
}
  
.eighty {
   font-size: 80%;
}
  
.seventy {
   font-size: 70%;
}
  
.container{
    display: flex;
}
.col{
    flex: 1;
}
</style>
</section>
<section id="review" class="slide level1">
<h1>Review</h1>
<ul>
<li>The Pumping Lemma is the formal tool we use to prove that the language B (as well as many other languages) is not regular.</li>
</ul>
</section>
<section id="the-pumping-lemma" class="slide level1">
<h1>The Pumping Lemma</h1>
<p><span class="math display">
\text{If A is a regular language and } \\ \exists p = \text{ the number of states in any machine for A }. \\
\forall w \text{ in A where } |w| \geq p \\ 
\exists x,y,z \text{ where } w = xyz, |y| &gt; 0, |xy| \leq p \\
\forall i &gt; 0, xy^iz \in A 
</span></p>
</section>
<section id="review-1" class="slide level1">
<h1>Review</h1>
<p><img data-src="images/lecture6-pumpinglemma.png" /></p>
</section>
<section id="context-free-grammars" class="slide level1">
<h1>Context-Free Grammars</h1>
</section>
<section id="introduction" class="slide level1">
<h1>Introduction</h1>
<ul>
<li>In this chapter we present context-free grammars (CFGs), a more powerful method of describing languages.</li>
<li>Such grammars can describe certain features that have a recursive structure, which makes them useful in a variety of applications.</li>
</ul>
</section>
<section id="cfgs" class="slide level1">
<h1>CFGs</h1>
<ul>
<li>Context-free grammars were first used in the study of human languages.</li>
<li>One way of understanding the relationship of terms such as noun, verb, and preposition and their respective phrases leads to a natural recursion because noun phrases may appear inside verb phrases and vice versa.</li>
<li>Context-free grammars help us organize and understand these relationships.</li>
</ul>
</section>
<section id="application" class="slide level1">
<h1>Application</h1>
<ul>
<li>An important application of context-free grammars occurs in the specification and compilation of programming languages.</li>
<li>A grammar for a programming language often appears as a reference for people trying to learn the language syntax.</li>
<li>Most compilers and interpreters contain a component called a parser that extracts the meaning of a program prior to creating the compiled code or performing the interpreted execution.</li>
</ul>
</section>
<section id="context-free-grammars-1" class="slide level1">
<h1>Context-free Grammars</h1>
</section>
<section id="cfgs-1" class="slide level1">
<h1>CFGs</h1>
<ul>
<li>The following is an example of a context-free grammar, which we call G<sub>1</sub>.</li>
</ul>
<p><span class="math display">
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
</span></p>
</section>
<section id="cfg-components" class="slide level1">
<h1>CFG Components</h1>
<ul>
<li>collection of <strong>substitution rules</strong>, also called productions.</li>
<li>Each rule appears as a line in the grammar, comprising a symbol and a string separated by an arrow.</li>
<li>The symbol is called a <strong>variable</strong>.</li>
<li>The string consists of variables and other symbols called <strong>terminals</strong>.</li>
</ul>
</section>
<section id="cfgs-2" class="slide level1">
<h1>CFGs</h1>
<ul>
<li>The variable symbols often are represented by capital letters.</li>
<li>The terminals are analogous to the input alphabet and often are represented by lowercase letters, numbers, or special symbols.</li>
<li>One variable is designated as the <strong>start variable</strong>.</li>
<li>It usually occurs on the left-hand side of the topmost rule.</li>
</ul>
</section>
<section id="example-cfg-g1" class="slide level1">
<h1>Example CFG G1</h1>
<p><span class="math display">
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
</span></p>
<ul>
<li>For example, grammar G<sub>1</sub> contains three rules.</li>
<li>G<sub>1</sub>’s variables are A and B, where A is the start variable.</li>
<li>Its terminals are 0, 1, and #.</li>
</ul>
</section>
<section id="generating-strings" class="slide level1">
<h1>Generating Strings</h1>
<ol type="1">
<li>Write down the start variable. It is the variable on the left-hand side of the top rule, unless specified otherwise.</li>
<li>Find a variable that is written down and a rule that starts with that variable. Replace the written down variable with the right-hand side of that rule.</li>
<li>Repeat step 2 until no variables remain.</li>
</ol>
</section>
<section id="generating" class="slide level1">
<h1>Generating</h1>
<p>G1: <span class="math display">
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
</span></p>
<ul>
<li>G<sub>1</sub> generates 000#111.<br />
</li>
<li>The sequence of substitutions to obtain a string is called its <strong>derivation</strong>.</li>
</ul>
</section>
<section id="derivation" class="slide level1">
<h1>Derivation</h1>
<p><span class="math display">
A \longrightarrow 0A1 \\
A\longrightarrow B \\
B\longrightarrow \#
</span></p>
<ul>
<li>A derivation of string 000#111 in grammar G<sub>1</sub> is: <span class="math display"> A \Rightarrow 0A1 \Rightarrow 00A11 \Rightarrow 000A111 \\ \Rightarrow 000B111 \Rightarrow 000\#111 </span></li>
</ul>
</section>
<section id="parse-tree" class="slide level1">
<h1>Parse Tree</h1>
<p>A derivation may be pictures pictorially using a <strong>parse tree</strong>.</p>
</section>
<section id="parse-tree-1" class="slide level1">
<h1>Parse Tree</h1>
<img data-src="lecture7-diagram1.png" title="fig:" class="stretch" alt="Parse Tree of G1" />
</section>
<section id="context-free-languages" class="slide level1">
<h1>Context-Free Languages</h1>
<ul>
<li>All strings generated in this way constitute the language of the grammar.</li>
<li>We write <span class="math inline">L(G_1)</span> for the language of Grammar <span class="math inline">G_1</span>.</li>
<li><span class="math inline">L(G_{1}) = \{0^n\#1^n | n \geq 0\}</span></li>
<li><strong>Any language that can be generated by some context-free grammar is called a context-free language (CFL)</strong></li>
</ul>
</section>
<section id="cfg-example-g2" class="slide level1 seventy">
<h1>CFG Example G2</h1>
<p><span class="math display">{\scriptsize\begin{aligned}⟨SENTENCE⟩ &amp;\longrightarrow ⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩
\\ ⟨NOUN-PHRASE⟩ &amp;\longrightarrow ⟨CMPLX-NOUN⟩ | ⟨CMPLX-NOUN⟩⟨PREP-PHRASE⟩
\\ ⟨VERB-PHRASE⟩ &amp;\longrightarrow ⟨CMPLX-VERB⟩ | ⟨CMPLX-VERB⟩⟨PREP-PHRASE⟩
\\ ⟨PREP-PHRASE⟩ &amp;\longrightarrow ⟨PREP⟩⟨CMPLX-NOUN⟩
\\ ⟨CMPLX-NOUN⟩ &amp;\longrightarrow ⟨ARTICLE⟩⟨NOUN⟩
\\ ⟨CMPLX-VERB⟩ &amp;\longrightarrow ⟨VERB⟩ | ⟨VERB⟩⟨NOUN-PHRASE⟩
\\ ⟨ARTICLE⟩ &amp;\longrightarrow a | the
\\ ⟨NOUN⟩ &amp;\longrightarrow boy | girl | flower
\\ ⟨VERB⟩ &amp;\longrightarrow touches | likes | sees
\\ ⟨PREP⟩ &amp;\longrightarrow with
\end{aligned} } </span></p>
</section>
<section id="cfg-example-g2-1" class="slide level1">
<h1>CFG Example G2</h1>
<p>Grammar G<sub>2</sub> has:</p>
<ul>
<li>10 variables (the capitalized grammatical terms written inside brackets)</li>
<li>27 terminals (the standard English alphabet plus a space character)</li>
<li>18 rules.</li>
</ul>
</section>
<section id="cfg-example-g2-2" class="slide level1">
<h1>CFG Example G2</h1>
<p>Strings in L(G<sub>2</sub>) include:</p>
<ul>
<li>a boy sees</li>
<li>the boy sees a flower</li>
<li>a girl with a flower likes the boy</li>
</ul>
</section>
<section id="cfg-example-g2-3" class="slide level1 seventy">
<h1>CFG Example G2</h1>
<p>The following is a derivation of <code>a boy sees</code>:</p>
<p><span class="math display">\begin{aligned}⟨SENTENCE⟩ &amp;\Rightarrow ⟨NOUN-PHRASE⟩⟨VERB-PHRASE⟩ \\ &amp;\Rightarrow ⟨CMPLX-NOUN⟩⟨VERB-PHRASE⟩
\\ &amp;\Rightarrow ⟨ARTICLE⟩⟨NOUN⟩⟨VERB-PHRASE⟩ \\ &amp;\Rightarrow a ⟨NOUN⟩⟨VERB-PHRASE⟩
\\ &amp;\Rightarrow a\, boy ⟨VERB-PHRASE⟩
\\ &amp;\Rightarrow a\, boy ⟨CMPLX-VERB⟩
\\ &amp;\Rightarrow a\, boy ⟨VERB⟩ \\ &amp;\Rightarrow a\, boy\ sees \end{aligned}</span></p>
</section>
<section id="formal-definition" class="slide level1">
<h1>Formal Definition</h1>
</section>
<section id="formal-definition-of-a-cfg" class="slide level1">
<h1>Formal Definition of a CFG</h1>
<p>A context-free grammar is a 4-tuple (V, Σ, R, S), where:</p>
<ol type="1">
<li>V is a finite set called the variables,</li>
<li>Σ is a finite set, disjoint from V , called the terminals,</li>
<li>R is a finite set of rules, with each rule being a variable and a string of variables and terminals, and</li>
<li>S ∈ V is the start variable.</li>
</ol>
</section>
<section id="terminology" class="slide level1">
<h1>Terminology</h1>
<ul>
<li>If u, v, and w are strings of variables and terminals, and A → w is a rule of the grammar, we say that uAv <strong>yields</strong> uwv, written uAv ⇒ uwv.</li>
<li>Say that u <strong>derives</strong> v, written u <span class="math inline">\xRightarrow{*}</span> v, if <span class="math inline">u = v</span> or if a sequence <span class="math inline">u_{1},u_{2},...,u_{k}</span> exists for k ≥ 0 and</li>
</ul>
<p><span class="math display"> u \Rightarrow u_{1} \Rightarrow u_{2} \Rightarrow ...\Rightarrow u_{k}\Rightarrow v.</span></p>
</section>
<section id="language-of-a-grammar" class="slide level1">
<h1>Language of a Grammar</h1>
<ul>
<li>The language of the grammar is:</li>
</ul>
<p><span class="math display">\{w \isin \Sigma ^∗\ |\ S \xRightarrow{*} w\}.</span></p>
</section>
<section id="example-g4" class="slide level1 eighty">
<h1>Example G4</h1>
<p>Consider grammar G<sub>4</sub> =(V,Σ,R,⟨EXPR⟩).</p>
<ul>
<li>V is {⟨EXPR⟩,⟨TERM⟩,⟨FACTOR⟩}</li>
<li>Σ is {a,+, x,(,)}</li>
<li>The rules are:</li>
</ul>
<p><span class="math display">\begin{aligned}⟨EXPR⟩ &amp;\Rightarrow ⟨EXPR⟩+⟨TERM⟩\ |\ ⟨TERM⟩ \\
⟨TERM⟩ &amp;\Rightarrow ⟨TERM⟩\times \text{⟨FACTOR⟩ |  ⟨FACTOR⟩} \\
  ⟨FACTOR⟩ &amp;\Rightarrow \text{ (⟨EXPR⟩) | a } \end{aligned} </span></p>
</section>
<section id="example-g4-1" class="slide level1 ninety">
<h1>Example G4</h1>
<p><span class="math display">\begin{aligned}⟨EXPR⟩ &amp;\Rightarrow ⟨EXPR⟩+⟨TERM⟩\ |\ ⟨TERM⟩ \\
⟨TERM⟩ &amp;\Rightarrow ⟨TERM⟩\times \text{⟨FACTOR⟩ |  ⟨FACTOR⟩} \\
  ⟨FACTOR⟩ &amp;\Rightarrow \text{ (⟨EXPR⟩) | a } \end{aligned} </span></p>
<p>Draw parse trees for <span class="math inline">a+a\times a</span> and <span class="math inline">(a+a)\times a</span>.</p>
</section>
<section id="example-g4-2" class="slide level1 eighty">
<h1>Example G4</h1>
<p>Draw parse trees for <span class="math inline">a+a\times a</span> and <span class="math inline">(a+a)\times a</span>.</p>
<figure>
<img data-src="lecture7-diagram2.png" alt="" /><figcaption>G4 Parse Trees</figcaption>
</figure>
</section>
<section id="compiler" class="slide level1">
<h1>Compiler</h1>
<ul>
<li>A compiler translates code written in a programming language into another form, usually one more suitable for execution.</li>
<li>To do so, the compiler extracts the meaning of the code to be compiled in a process called parsing.</li>
<li>One representation of this meaning is the parse tree for the code, in the context-free grammar for the programming language</li>
</ul>
</section>
<section id="designing-context-free-grammars" class="slide level1">
<h1>Designing Context-Free Grammars</h1>
</section>
<section id="designing-cfgs" class="slide level1">
<h1>Designing CFGs</h1>
<ul>
<li>As with the design of finite automata, the design of context-free grammars requires creativity.</li>
<li>Context-free grammars are even trickier to construct than finite automata because we are more accustomed to programming a machine for specific tasks than we are to describing languages with grammars.</li>
</ul>
</section>
<section id="technique-1" class="slide level1 ninety">
<h1>Technique 1</h1>
<ul>
<li>Many CFLs are the union of simpler CFLs. If you must construct a CFG for a CFL that you can break into simpler pieces, do so and then construct individual grammars for each piece.</li>
<li>These individual grammars can be easily merged into a grammar for the original language by combining their rules</li>
<li>Then add the new rule <span class="math inline">S → S_{1} | S_{2} | ··· | S_{k},</span> where the variables <span class="math inline">S_i</span> are the start variables for the individual grammars</li>
</ul>
</section>
<section id="technique-2" class="slide level1">
<h1>Technique 2</h1>
<ul>
<li>Constructing a CFG for a language that happens to be regular is easy if you can first construct a DFA for that language.</li>
<li>You can convert any DFA into an equivalent CFG as follows.</li>
</ul>
</section>
<section id="technique-2-1" class="slide level1 ninety">
<h1>Technique 2</h1>
<ol type="1">
<li>Make a variable <span class="math inline">R_i</span> for each state qi of the DFA.</li>
<li>Add the rule <span class="math inline">R_i \longrightarrow aR_j</span> to the CFG if <span class="math inline">\delta(q_i,a) = q_j</span> is a transition in the DFA.</li>
<li>Add the rule <span class="math inline">R_i \longrightarrow \epsilon</span> if <span class="math inline">q_i</span> is an accept state of the DFA.</li>
<li>Make <span class="math inline">R_0</span> the start variable of the grammar, where <span class="math inline">q_0</span> is the start state of the machine.</li>
<li>Verify on your own that the resulting CFG generates the same language that the DFA recognizes.</li>
</ol>
</section>
<section id="technique-3" class="slide level1 ninety">
<h1>Technique 3</h1>
<ul>
<li>CFLs contain strings with two substrings that are “linked” in the sense that a machine for such a language would need to remember an unbounded amount of information about one of the substrings to verify that it corresponds properly to the other substring</li>
<li>This situation occurs in the language <span class="math inline">\{0^n1^n| n \geq 0\}</span> because a machine would need to remember the number of 0s in order to verify that it equals the number of 1s.</li>
</ul>
</section>
<section id="technique-3-1" class="slide level1">
<h1>Technique 3</h1>
<ul>
<li>You can construct a CFG to handle this situation by using a rule of the form R → uRv, which generates strings wherein the portion containing the u’s corresponds to the portion containing the v’s.</li>
</ul>
</section>
<section id="technique-4" class="slide level1">
<h1>Technique 4</h1>
<ul>
<li>In more complex languages, the strings may contain certain structures that appear recursively as part of other (or the same) structures.</li>
<li>That situation occurs in the grammar that generates arithmetic expressions in Example 2.4.</li>
</ul>
</section>
<section id="technique-4-1" class="slide level1">
<h1>Technique 4</h1>
<ul>
<li>Any time the symbol a appears, an entire parenthesized expression might appear recursively instead.</li>
<li>To achieve this effect, place the variable symbol generating the structure in the location of the rules corresponding to where that structure may recursively appear.</li>
</ul>
</section>
<section id="ambiguity" class="slide level1">
<h1>Ambiguity</h1>
</section>
<section id="ambiguity-1" class="slide level1">
<h1>Ambiguity</h1>
<ul>
<li>Sometimes a grammar can generate the same string in several different ways.</li>
<li>Such a string will have several different parse trees and thus several different meanings.</li>
<li>This result may be undesirable for certain applications, such as programming languages, where a program should have a unique interpretation.</li>
</ul>
</section>
<section id="ambiguity-2" class="slide level1">
<h1>Ambiguity</h1>
<ul>
<li>If a grammar generates the same string in several different ways, we say that the string is derived ambiguously in that grammar.</li>
<li>If a grammar generates some string ambiguously, we say that the grammar is ambiguous.</li>
</ul>
</section>
<section id="ambiguity-3" class="slide level1">
<h1>Ambiguity</h1>
<p>Consider G5:</p>
<p>⟨EXPR⟩ → ⟨EXPR⟩+⟨EXPR⟩ | ⟨EXPR⟩x⟨EXPR⟩ |(⟨EXPR⟩)|a</p>
<p>This grammar generates the string a + a x a ambiguously.</p>
</section>
<section id="ambiguity-4" class="slide level1">
<h1>Ambiguity</h1>
<p>Consider G5:</p>
<p>⟨EXPR⟩ → ⟨EXPR⟩+⟨EXPR⟩ | ⟨EXPR⟩x⟨EXPR⟩ |(⟨EXPR⟩)|a</p>
<figure>
<img data-src="lecture7-diagram3.png" alt="" /><figcaption>Diagram 3</figcaption>
</figure>
</section>
<section id="ambiguity-5" class="slide level1">
<h1>Ambiguity</h1>
<ul>
<li>Sometimes when we have an ambiguous grammar we can find an unambiguous grammar that generates the same language.</li>
<li>Some context-free languages, however, can be generated only by ambiguous grammars. Such languages are called <em>inherently ambiguous</em>.</li>
</ul>
</section>
<section id="formal-defintion-of-ambiguity-27" class="slide level1">
<h1>Formal Defintion of Ambiguity (2.7)</h1>
<p>A string w is derived ambiguously in context-free grammar G if it has two or more different leftmost derivations. Grammar G is ambiguous if it generates some string ambiguously.</p>
</section>
<section id="leftmost-derivation" class="slide level1">
<h1>Leftmost Derivation</h1>
<p>A derivation of a string w in a grammar G is a leftmost derivation if at every step the leftmost remaining variable is the one replaced.</p>
</section>
<section id="chomsky-normal-form" class="slide level1">
<h1>Chomsky Normal Form</h1>
</section>
<section id="chomsky-normal-form-1" class="slide level1">
<h1>Chomsky Normal Form</h1>
<p>When working with context-free grammars, it is often convenient to have them in simplified form. One of the simplest and most useful forms is called the Chomsky Normal Form.</p>
</section>
<section id="chomsky-normal-form-2" class="slide level1 eighty">
<h1>Chomsky Normal Form</h1>
<ul>
<li>A context-free grammar is in Chomsky normal form if every rule is of the form:</li>
</ul>
<p><span class="math display"> \begin{aligned} A &amp;\longrightarrow BC \\ A &amp;\longrightarrow a \end{aligned} </span></p>
<ul>
<li>where a is any terminal</li>
<li>and A, B, and C are any variables—except that B and C may not be the start variable.</li>
<li>In addition, we permit the rule S → ε, where S is the start variable.</li>
</ul>
</section>
<section id="conversion-to-cnf" class="slide level1">
<h1>Conversion to CNF</h1>
<ol type="1">
<li>Add a new start variable <span class="math inline">S_0</span> and the rule <span class="math inline">S_0</span> → S, where S was the original start variable.</li>
<li>Take care of all ε-rules. We remove an ε-rule A → ε, where A is not the start variable. Then for each occurrence of an A on the right-hand side of a rule, we add a new rule with that occurrence deleted.</li>
<li>Remove all unit rules. We remove a unit rule A → B.</li>
</ol>
</section>
<section id="conversion-to-cnf-1" class="slide level1 ninety">
<h1>Conversion to CNF</h1>
<ol start="4" type="1">
<li>Finally, we convert all remaining rules into the proper form.</li>
</ol>
<ul>
<li>We replace each rule <span class="math inline">A → u_{1}u_{2} ···u_{k}</span>, where k ≥ 3 and each <span class="math inline">u_i</span> is a variable or terminal symbol,with the rules <span class="math inline">A → u_{1}A_{1}, A_{1} → u_{2}A_{2}, \\ A_{2} → u_{3}A_{3}, ...\text{ , and }A_{k}−2 → u_{k−1}u_{k}</span>.</li>
<li>The <span class="math inline">A_{i}</span>’s are new variables.</li>
<li>We replace any terminal <span class="math inline">u_{i}</span> in the preceding rule(s) with the new variable <span class="math inline">U_{i}</span> and add the rule <span class="math inline">U_{i} → u_{i}</span>.</li>
</ul>
</section>
<section id="conversion-example" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>Initial Grammar G<sub>6</sub>: <span class="math display"> \begin{aligned} S &amp;\longrightarrow ASA\ |\ aB \\ A&amp;\longrightarrow B\ |\ S \\ B &amp;\longrightarrow b\ |\ \epsilon \end{aligned}</span></p>
<p>First, add new start rule <span class="math inline">S_0</span>.</p>
</section>
<section id="conversion-example-1" class="slide level1 ninety">
<h1>Conversion Example</h1>
<ol type="1">
<li>Add new start rule S<sub>0</sub>: <span class="math display"> \begin{aligned} S_0 &amp;\longrightarrow S \\ S &amp;\longrightarrow ASA\ |\ aB \\ A&amp;\longrightarrow B\ |\ S \\ B &amp;\longrightarrow b\ |\ \epsilon \end{aligned}</span></li>
</ol>
<p>Second, take care of all ε-rules.</p>
</section>
<section id="conversion-example-2" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>2a. Take care of all <span class="math inline">B \longrightarrow \epsilon</span>-rules: <span class="math display"> \begin{aligned} S_0 &amp;\longrightarrow S \\ S &amp;\longrightarrow ASA\ |\ aB\ |\ a \\ A&amp;\longrightarrow B\ |\ S\ |\ \epsilon \\ B &amp;\longrightarrow b \end{aligned}</span></p>
<p>Next, remove all <span class="math inline">A \longrightarrow \epsilon</span>-rules.</p>
</section>
<section id="conversion-example-3" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>2b. Take care of all <span class="math inline">A \longrightarrow \epsilon</span>-rules: <span class="math display"> \begin{aligned} S_0 &amp;\longrightarrow S \\
S &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS\ |\ S\\
A&amp;\longrightarrow B\ |\ S \\
 B &amp;\longrightarrow b \end{aligned}</span></p>
<p>Next, remove all unit rules.</p>
</section>
<section id="conversion-example-4" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>3a. Remove unit rule <span class="math inline">S\longrightarrow S</span> <span class="math display"> \begin{aligned} S_0 &amp;\longrightarrow S \\
S &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS \\
A&amp;\longrightarrow B\ |\ S \\
 B &amp;\longrightarrow b \end{aligned}</span></p>
<p>Next, remove unit rule <span class="math inline">S_0 \longrightarrow S</span></p>
</section>
<section id="conversion-example-5" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>3b. Remove unit rule <span class="math inline">S_0 \longrightarrow S</span></p>
<p><span class="math display"> \begin{aligned} S_0 &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS\ \\
S &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS \\
A&amp;\longrightarrow B\ |\ S \\
 B &amp;\longrightarrow b \end{aligned}</span></p>
<p>Next, remove unit rule <span class="math inline">A\longrightarrow B</span></p>
</section>
<section id="conversion-example-6" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>3c. Remove unit rule <span class="math inline">A\longrightarrow B</span> <span class="math display"> \begin{aligned} S_0 &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS\ \\
S &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS \\
A&amp;\longrightarrow  S\ |\ b \\
 B &amp;\longrightarrow b \end{aligned}</span></p>
<p>Next, remove unit rule <span class="math inline">A\longrightarrow S</span></p>
</section>
<section id="conversion-example-7" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>3c. Remove unit rule <span class="math inline">A\longrightarrow S</span> <span class="math display"> \begin{aligned} S_0 &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS\ \\
S &amp;\longrightarrow ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS  \\
A&amp;\longrightarrow   b\ |\ ASA\ |\ aB\ |\ a \ |\ SA\ |\ AS\ \\
 B &amp;\longrightarrow b \end{aligned}</span></p>
</section>
<section id="conversion-example-8" class="slide level1 ninety">
<h1>Conversion Example</h1>
<ul>
<li>Next, convert remaining rules to the proper form by adding additional variables and rules.</li>
<li>No rule should have a mix of variables and terminals, and it should have no more than 2 variables in each production.</li>
<li>The final grammar is equivalent to <span class="math inline">G_6</span>.</li>
</ul>
</section>
<section id="conversion-example-9" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>Initial Grammar G<sub>6</sub>: <span class="math display"> \begin{aligned} S &amp;\longrightarrow ASA\ |\ aB \\ A&amp;\longrightarrow B\ |\ S \\ B &amp;\longrightarrow b\ |\ \epsilon \end{aligned}</span></p>
</section>
<section id="conversion-example-10" class="slide level1 ninety">
<h1>Conversion Example</h1>
<p>G<sub>6</sub> equivalent in CNF: <span class="math display"> \begin{aligned} S_0 &amp;→AA_{1}\ |\ UB\ |\ a\ |\ SA\ |\ AS \\
S &amp;→ AA_{1}\ |\ UB\ |\ a\ |\ SA\ |\ AS \\
A &amp;→b\ |\ AA_{1}\ |\ UB\ |\ a\ |\ SA\ |\ AS \\
A_{1} &amp;→ SA \\
U&amp;→a \\
B&amp;→b \end{aligned}</span></p>
</section>
<section id="review-2" class="slide level1">
<h1>Review</h1>
<ul>
<li>In this chapter we present context-free grammars (CFGs), a more powerful method of describing languages.</li>
<li>Such grammars can describe certain features that have a recursive structure, which makes them useful in a variety of applications.</li>
</ul>
</section>
<section id="cfgs-3" class="slide level1">
<h1>CFGs</h1>
<ul>
<li>Context-free grammars were first used in the study of human languages.</li>
<li>One way of understanding the relationship of terms such as noun, verb, and preposition and their respective phrases leads to a natural recursion because noun phrases may appear inside verb phrases and vice versa.</li>
<li>Context-free grammars help us organize and understand these relationships.</li>
</ul>
</section>
<section id="cfgs-4" class="slide level1">
<h1>CFGS</h1>
<ul>
<li>CFGs <em>generate</em> strings</li>
<li>Strings can be <em>derived</em> from CFGs</li>
<li>Some strings may be <em>ambiguous</em></li>
<li>CFGs can be convereted to a standard form known as Chomsky Normal Form</li>
<li>CFGs are important in their application to compilation</li>
</ul>
</section>
<section id="references-resources" class="slide level1">
<h1>References, Resources</h1>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PL601FC994BDD963E4">ADUni.org Lectures</a></li>
<li><a href="https://cseweb.ucsd.edu/classes/fa08/cse105/">UC San Diego Lecture Slides</a></li>
</ul>
</section>
    </div>
  </div>

  <script src="../../../presentation/reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: '../../../presentation/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../../../presentation/reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: '../../../presentation/reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
